---
title: "Part3_Prediction_Model"
author: "Ilse van Beelen"
date: "11/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```


```{r}

set.seed(19950306)

# Load libraries
rm(list = ls())
library(ggplot2)
library(lme4)
library(tidyverse)
library(nlme)
library(emmeans)
library(car)
library(lattice)
library(merTools)
library(xtable)

# Set layout for all figures
theme <- theme(panel.background = element_blank(),
          panel.grid.major = element_line(colour = "darkgrey", size=0.5),
          panel.grid.minor = element_line(colour = "grey", 
                                          size=.25, 
                                          linetype = "dashed"),
          panel.border = element_blank(),
          axis.line.x = element_line(colour = "black", 
                                     size=0.5, 
                                     lineend = "butt"),
          axis.line.y = element_line(colour = "black", 
                                     size=0.5),
          axis.text=element_text(size=15),
              axis.title=element_text(size=22),
              plot.title = element_text(size = 22),
              strip.text = element_text(size = 15),
              legend.title = element_blank())



df_long <- read.csv("Data/data_final_2019-11-05.csv", sep = ",")

# Some data wrangling
df_long <- df_long %>% 
  mutate(hads_tot = hads_depr + hads_anx) %>%
  dplyr::select(id, ndi, time, hads_tot, hads_anx, hads_depr) %>%
  mutate(ndi = as.numeric(ndi), time = as.numeric(time),
         hads_tot = as.numeric(hads_tot), time_fct = as.factor(time))
  

# Create new dataframe with HADS at time = 0 & NDI at time = 0
df_time0 <- df_long[df_long$time == 0, ]
df_time0 <- dplyr::select(df_time0, id, ndi, hads_tot, hads_anx, hads_depr)
colnames(df_time0) <-  c("id", "ndi0", "hads0_tot", "hads0_anx", "hads0_depr")

# Create new dataframe with HADS and NDI at 52 and 104 weeks
df_time1_2 <- df_long[df_long$time != 0, ]
df_time1_2 <- dplyr::select(df_time1_2, id, ndi, time_fct)
colnames(df_time1_2) <-  c("id", "ndi1_2", "time_fct")

# Merge dataframes
df_prediction <- merge(df_time1_2, df_time0, by = "id")

```


# Prediction Model

Final model is fitted with REML

We fit the following prediction model. It turns out that Time is not significant, therefore we remove this variable. Note that the models below are fitting with Maximum Likelihood (ML)

$$NDI_{i1,i2} = \beta_0 + \beta_1 HADS_{i0} + \beta_2 NDI_{i0} + \beta_3 Time_{i1, i2} + b_{i0} + \varepsilon_{i1, i2} \\
i = 1,2,3, \ldots, 109$$

```{r}
model_final <- nlme::lme(ndi1_2 ~ ndi0 + hads0_anx + hads0_depr + time_fct, method = "REML",
                         random = ~1|id, data = df_prediction)

summary(model_final)

model_final_coef <- data.frame(coef(summary(model_final)))
xtable(model_final_coef)

# Calculate ICC (amount of var explained)
12.04098^2 / (12.04098^2 + 8.958211^2)

```

Make prediction for a "new patient" with 95 % confidence intervals. We do this twice

```{r}

# Make prediction for subject L8141003
validation1 <- df_prediction[df_prediction$id == "L8141003",]
training1 <- df_prediction[df_prediction$id != "L8141003", ]

# Make prediction for subject L8105004
validation1 <- df_prediction[df_prediction$id == "L8105004",]
training1 <- df_prediction[df_prediction$id != "L8105004", ]

training.fit <-  lmer(ndi1_2 ~ ndi0 + hads0_anx + hads0_depr + time_fct + (1|id), 
                    data = training1, REML = T)


preds1 <- predictInterval(model_final, newdata = validation1, n.sims = 999)
validation1 <- cbind(validation1, preds1)

# Make prediction for subject L8061024
validation2 <- df_prediction[df_prediction$id == "L8061024",]
training2 <- df_prediction[df_prediction$id != "L8061024",]

training.fit <-  lmer(ndi1_2 ~ ndi0 + hads0_anx + hads0_depr + time_fct + (1|id), 
                    data = training2, REML = T)

preds2 <- predictInterval(model_final, newdata = validation2, n.sims = 999)
validation2 <- cbind(validation2, preds2)


# Combine predictions in one dataframe and plot the results
predict_2id <- rbind(validation1, validation2)

```

Plot the two predictions

```{r}

predict_2id$time <- as.numeric(as.character(predict_2id$time_fct))

predict_2id <- predict_2id %>%
  #add_row(id = "L8141003", ndi1_2 = 44, fit = 44, time = 0, upr = 44, lwr = 44, .before = 1) %>%
  add_row(id = "L8105004", ndi1_2 = 44, fit = 44, time = 0, upr = 44, lwr = 44, .before = 1) %>%
  add_row(id = "L8061024", ndi1_2 = 42, fit = 42, time = 0, upr = 42, lwr = 42, .before =  4)

ppredict <- ggplot(data = predict_2id, aes(x = time, y = ndi1_2)) + 
  geom_line(size = 1.5, col = "black") +
  geom_point(size = 3, col = "black") +
  geom_line(aes(x = time, y = fit, col = id), size = 1.5) +
  geom_point(aes(x = time, y = fit, col = id), size = 3, shape = 17) +
  geom_ribbon(aes(ymin= lwr, ymax= upr, col = id, fill = id), alpha=0.3) + theme +
  ylab("NDI") + xlab("Time (weeks)") +  facet_grid(~id) + theme(legend.position = "none")

plot(ppredict)

png("Figures/Predicted_ids.png",width = 15, height = 7, units='in',res=300)
plot(ppredict)
dev.off()


```



# Cross validation


Below we divide the data in 5 folds

```{r}

# Create folds
K <- 5
index <- rep(1:K, floor(nrow(df_prediction)/K)+1)[1:nrow(df_prediction)]
fold.index <- sample(index)


# Create Loss function: Root Mean Squard Error
Loss <- function(x, y){
  mse <- sum((x-y)^2)/length(x)
  rmse <- sqrt(mse)
  return(rmse)
}

loss <- numeric(K)

for (k in 1:K){
  training <- df_prediction[fold.index!=k, ]
  validation <- df_prediction[fold.index==k, ]
  training.fit <-  lme4::lmer(ndi1_2 ~ ndi0 + hads0_anx + hads0_depr + time_fct + (1|id), 
                    data = training, REML = T)
  
  validation.predict <- predict(training.fit, newdata=validation, type='response', 
                                allow.new.levels = T)
  loss[k] <- Loss(validation$ndi1_2, validation.predict)
}

loss
round(mean(loss), digits = 1)

```

